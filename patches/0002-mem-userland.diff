diff --git a/Userland/SampleCodeModule/Makefile b/Userland/SampleCodeModule/Makefile
index 65f4382..f24a003 100644
--- a/Userland/SampleCodeModule/Makefile
+++ b/Userland/SampleCodeModule/Makefile
@@ -11,10 +11,10 @@ OBJECTS_ASM=$(SOURCES_ASM:asm/%.asm=obj/%.asm.o)
 all: $(MODULE) $(MODULE_ELF)
 
 $(MODULE): $(SOURCES) $(SOURCES_TESTS) $(SOURCES_SH) $(OBJECTS_ASM)
-	$(GCC) $(GCCFLAGS) -I./include -I./tests -I./sh -T sampleCodeModule.ld _loader.c $(OBJECTS_ASM) $(SOURCES) $(SOURCES_TESTS) $(SOURCES_SH) -o ../$(MODULE)
+	$(GCC) $(GCCFLAGS) -I./include -I../include -I./tests -I./sh -T sampleCodeModule.ld _loader.c $(OBJECTS_ASM) $(SOURCES) $(SOURCES_TESTS) $(SOURCES_SH) -o ../$(MODULE)
 
 $(MODULE_ELF): $(SOURCES) $(SOURCES_TESTS) $(SOURCES_SH) $(OBJECTS_ASM)
-	$(GCC) $(GCCFLAGS) -I./include -I./tests -I./sh -T sampleCodeModule.ld -Wl,--oformat=elf64-x86-64 _loader.c $(OBJECTS_ASM) $(SOURCES) $(SOURCES_TESTS) $(SOURCES_SH) -o ../$(MODULE_ELF)
+	$(GCC) $(GCCFLAGS) -I./include -I../include -I./tests -I./sh -T sampleCodeModule.ld -Wl,--oformat=elf64-x86-64 _loader.c $(OBJECTS_ASM) $(SOURCES) $(SOURCES_TESTS) $(SOURCES_SH) -o ../$(MODULE_ELF)
 
 obj/%.asm.o : asm/%.asm
 	mkdir -p obj
diff --git a/Userland/SampleCodeModule/asm/sys_calls.asm b/Userland/SampleCodeModule/asm/sys_calls.asm
index bffe43a..96f673d 100644
--- a/Userland/SampleCodeModule/asm/sys_calls.asm
+++ b/Userland/SampleCodeModule/asm/sys_calls.asm
@@ -20,6 +20,7 @@ GLOBAL sys_stopSpeaker
 GLOBAL sys_malloc
 GLOBAL sys_free
 GLOBAL sys_mem_info
+GLOBAL sys_mm_get_stats
 GLOBAL sys_getpid
 GLOBAL sys_create_process
 GLOBAL sys_kill
@@ -165,6 +166,11 @@ sys_mem_info:
     int 80h
     ret
 
+sys_mm_get_stats:
+    mov rax, 0x2E
+    int 80h
+    ret
+
 sys_getpid:
     mov rax, 0x15
     int 80h
diff --git a/Userland/SampleCodeModule/include/sys_calls.h b/Userland/SampleCodeModule/include/sys_calls.h
index 6de82cb..723b925 100644
--- a/Userland/SampleCodeModule/include/sys_calls.h
+++ b/Userland/SampleCodeModule/include/sys_calls.h
@@ -3,6 +3,7 @@
 
 #include <stdint.h>
 #include <colors.h>
+#include <mm_stats.h>
 
 // Wrapper de syscalls que el userland expone como librería estándar
 
@@ -73,6 +74,7 @@ void* sys_malloc(uint64_t size);
 uint64_t sys_free(void* ptr);
 
 uint64_t sys_mem_info(memory_info_t* info);
+int64_t sys_mm_get_stats(mm_stats_t *stats);
 
 // Process management syscalls
 int64_t sys_getpid();
diff --git a/Userland/SampleCodeModule/kitty.c b/Userland/SampleCodeModule/kitty.c
index 6669f13..3116886 100644
--- a/Userland/SampleCodeModule/kitty.c
+++ b/Userland/SampleCodeModule/kitty.c
@@ -285,10 +285,13 @@ void cmd_waitpid(void);
 void cmd_cat(void);
 void cmd_wc(void);
 void cmd_filter(void);
+void cmd_mem(void);
 void cmd_echo(void);
 void cmd_jobs(void);
 void printPrompt(void);
 
+extern int mem_command(int argc, char **argv);
+
 void printHelp()
 {
 	printsColor("\n\n===== Listing a preview of available commands =====\n", MAX_BUFF, GREEN);
@@ -309,6 +312,7 @@ void printHelp()
     printsColor("\n>yield              - yield the CPU", MAX_BUFF, LIGHT_BLUE);
     printsColor("\n>waitpid <pid|-1>  - wait for a child to finish", MAX_BUFF, LIGHT_BLUE);
 	printsColor("\n>echo <text>        - print text to stdout", MAX_BUFF, LIGHT_BLUE);
+	printsColor("\n>mem [-v]           - show memory usage statistics", MAX_BUFF, LIGHT_BLUE);
 	printsColor("\n>cat                - read from stdin and write to stdout", MAX_BUFF, LIGHT_BLUE);
 	printsColor("\n>wc                 - count lines from stdin", MAX_BUFF, LIGHT_BLUE);
 	printsColor("\n>filter             - remove vowels from stdin", MAX_BUFF, LIGHT_BLUE);
@@ -328,7 +332,7 @@ void printHelp()
 	printsColor("  cat | filter           - read input and filter vowels\n\n", MAX_BUFF, CYAN);
 }
 
-const char *commands[] = {"undefined", "help", "ls", "time", "clear", "registersinfo", "zerodiv", "invopcode", "exit", "ascii", "test_mm", "test_processes", "test_priority", "test_sync", "test_no_synchro", "test_synchro", "debug", "ps", "loop", "nice", "kill", "yield", "waitpid", "cat", "wc", "filter", "echo", "jobs", "sh"};
+const char *commands[] = {"undefined", "help", "ls", "time", "clear", "registersinfo", "zerodiv", "invopcode", "exit", "ascii", "test_mm", "test_processes", "test_priority", "test_sync", "test_no_synchro", "test_synchro", "debug", "ps", "loop", "nice", "kill", "yield", "waitpid", "mem", "cat", "wc", "filter", "echo", "jobs", "sh"};
 static void (*commands_ptr[MAX_ARGS])() = {
 	cmd_undefined,
 	cmd_help,
@@ -353,6 +357,7 @@ static void (*commands_ptr[MAX_ARGS])() = {
 	cmd_kill,
 	cmd_yield,
 	cmd_waitpid,
+	cmd_mem,
 	cmd_cat,
 	cmd_wc,
 	cmd_filter,
@@ -1539,6 +1544,33 @@ void cmd_waitpid()
 	printf("\nwaitpid -> child %d exited with status %d\n", (int)waited, status);
 }
 
+void cmd_mem()
+{
+	char *argvv[3] = {"mem", NULL, NULL};
+	char arg_buf[64];
+	int idx = 0;
+	int argc_local = 1;
+
+	if (parameter[0] != '\0') {
+		if (!next_token(parameter, &idx, arg_buf, sizeof(arg_buf))) {
+			printsColor("\nmem: invalid argument\n", MAX_BUFF, RED);
+			return;
+		}
+		argvv[argc_local++] = arg_buf;
+
+		char extra[16];
+		if (next_token(parameter, &idx, extra, sizeof(extra))) {
+			printsColor("\nmem: too many arguments\n", MAX_BUFF, RED);
+			return;
+		}
+	}
+
+	int status = mem_command(argc_local, argvv);
+	if (status != 0) {
+		printf("\nmem exited with status %d\n", status);
+	}
+}
+
 void cmd_cat()
 {
 	char *argv[1] = {"cat"};
diff --git a/Userland/SampleCodeModule/shell.c b/Userland/SampleCodeModule/shell.c
index 630b662..adedbb9 100644
--- a/Userland/SampleCodeModule/shell.c
+++ b/Userland/SampleCodeModule/shell.c
@@ -36,6 +36,7 @@ extern void cat_main(int argc, char **argv);
 extern void wc_main(int argc, char **argv);
 extern void filter_main(int argc, char **argv);
 extern void loop_main(int argc, char **argv);
+extern void mem_main(int argc, char **argv);
 
 // Wrappers para tests con firma diferente
 static void test_processes_wrapper(int argc, char **argv) {
@@ -80,6 +81,54 @@ static void test_synchro_wrapper(int argc, char **argv) {
     test_synchro(count, args);
 }
 
+static char **clone_args(char **argv, int count) {
+    if (argv == NULL || count <= 0) {
+        return NULL;
+    }
+
+    char **copy = (char **)sys_malloc(sizeof(char *) * (count + 1));
+    if (copy == NULL) {
+        return NULL;
+    }
+
+    for (int i = 0; i < count; i++) {
+        const char *src = argv[i];
+        if (src == NULL) {
+            copy[i] = NULL;
+            continue;
+        }
+        int len = strlen(src);
+        char *dst = (char *)sys_malloc((uint64_t)(len + 1));
+        if (dst == NULL) {
+            for (int j = 0; j < i; j++) {
+                if (copy[j] != NULL) {
+                    sys_free(copy[j]);
+                }
+            }
+            sys_free(copy);
+            return NULL;
+        }
+        for (int j = 0; j <= len; j++) {
+            dst[j] = src[j];
+        }
+        copy[i] = dst;
+    }
+    copy[count] = NULL;
+    return copy;
+}
+
+static void free_cloned_args(char **argv, int count) {
+    if (argv == NULL) {
+        return;
+    }
+    for (int i = 0; i < count; i++) {
+        if (argv[i] != NULL) {
+            sys_free(argv[i]);
+        }
+    }
+    sys_free(argv);
+}
+
 // Tabla de comandos integrados
 typedef struct {
     const char *name;
@@ -117,7 +166,8 @@ static int cmd_help(int argc, char **argv) {
     printf("  wc - Word count\n");
     printf("  filter - Filter vowels\n");
     printf("  loop - Infinite loop\n");
-    
+    printf("  mem [-v] - Show memory usage\n");
+
     printf("\nUse '&' at the end to run in background\n");
     printf("Example: loop &\n");
     
@@ -281,9 +331,6 @@ static int tokenize(char *line, char **argv, int max_args) {
 static int launch_process(const char *name, char **argv, int is_background) {
     void (*entry)(int, char **) = NULL;
     
-    // Suprimir warning de parámetro no usado (reservado para expansión futura)
-    (void)argv;
-    
     // Mapeo de nombres a funciones
     if (strcmp(name, "test_processes") == 0) {
         entry = test_processes_wrapper;
@@ -308,21 +355,43 @@ static int launch_process(const char *name, char **argv, int is_background) {
     } else if (strcmp(name, "test_fg_bg") == 0) {
         extern void test_fg_bg_main(int, char **);
         entry = test_fg_bg_main;
+    } else if (strcmp(name, "mem") == 0) {
+        entry = mem_main;
     } else {
         printf("Unknown command: %s\n", name);
         return -1;
     }
-    
+
+    int argc_total = 0;
+    if (argv != NULL) {
+        while (argv[argc_total] != NULL) {
+            argc_total++;
+        }
+    }
+
+    int arg_count = (argc_total > 1) ? (argc_total - 1) : 0;
+    char **argv_copy = NULL;
+    if (arg_count > 0) {
+        argv_copy = clone_args(&argv[1], arg_count);
+        if (argv_copy == NULL) {
+            printf("Failed to allocate arguments\n");
+            return -1;
+        }
+    }
+
     // Crear el proceso como background o foreground
     // Usar la nueva syscall que permite especificar el flag fg/bg
     int is_fg = is_background ? 0 : 1;
-    int64_t pid = sys_create_process_ex(entry, 0, NULL, name, 2, is_fg);
-    
+    int64_t pid = sys_create_process_ex(entry, arg_count, argv_copy, name, 2, is_fg);
+
     if (pid < 0) {
         printf("Failed to create process\n");
+        if (argv_copy != NULL) {
+            free_cloned_args(argv_copy, arg_count);
+        }
         return -1;
     }
-    
+
     if (is_background) {
         // Agregar a la lista de jobs y no esperar
         jobs_add(pid, name);
@@ -331,6 +400,9 @@ static int launch_process(const char *name, char **argv, int is_background) {
         // Foreground: esperar a que termine
         int status = 0;
         int waited = sys_wait_pid(pid, &status);
+        if (argv_copy != NULL) {
+            free_cloned_args(argv_copy, arg_count);
+        }
         if (waited > 0) {
             // Proceso terminado
             return 0;
diff --git a/Userland/include/mm_stats.h b/Userland/include/mm_stats.h
new file mode 100644
index 0000000..c4d1001
--- /dev/null
+++ b/Userland/include/mm_stats.h
@@ -0,0 +1,38 @@
+#ifndef MM_STATS_H
+#define MM_STATS_H
+
+#include <stdint.h>
+
+#define MM_NAME_MAX            16
+#define MM_MAX_ORDER           20
+#define MM_MAX_SIMPLE_BLOCKS   32
+
+typedef struct mm_order_info {
+    uint32_t order;
+    uint64_t block_size;
+    uint64_t free_count;
+} mm_order_info_t;
+
+typedef struct mm_block_info {
+    uint64_t addr;
+    uint64_t size;
+} mm_block_info_t;
+
+typedef struct mm_stats {
+    char     mm_name[MM_NAME_MAX];
+    uint64_t heap_total;
+    uint64_t used_bytes;
+    uint64_t free_bytes;
+    uint64_t free_blocks;
+    uint64_t largest_free;
+    uint8_t  has_buddy;
+    uint8_t  max_order;
+    mm_order_info_t orders[MM_MAX_ORDER];
+    uint64_t heap_base;
+    uint64_t heap_end;
+    uint32_t freelist_count;
+    uint32_t freelist_truncated;
+    mm_block_info_t freelist[MM_MAX_SIMPLE_BLOCKS];
+} mm_stats_t;
+
+#endif /* MM_STATS_H */
